# UI Component Documentation Developer Guide

**Version**: 1.0  
**Last Updated**: 2025-11-03  
**For**: Developers documenting React/TypeScript UI components  
**Related**: AKR_CHARTER_UI.md, ui_component_template.md

---

## Purpose

This guide shows you **exactly how** to document UI components using the AKR system. It's practical, step-by-step, and designed to work with GitHub Copilot for maximum efficiency.

**Target time**: 20-25 minutes per component (baseline documentation)

**What you'll learn**:
1. Which component files to attach to Copilot for best results
2. Standard prompts that work consistently
3. How to enhance AI-generated documentation
4. Common scenarios and solutions

---

## Quick Start (5-Minute Version)

If you're experienced and just need a reminder:

### Using VS Code with Copilot
1. **Gather context**: Component file + props interface + usage examples
2. **Copy template**: `ui_component_template.md` ‚Üí `docs/components/[ComponentName]_doc.md`
3. **Open Copilot Chat**: Ctrl+Shift+I
4. **Attach files**: @ui_component_template.md @ComponentName.tsx @ComponentName.test.tsx
5. **Use standard prompt**: See "Standard Prompt for VS Code/Visual Studio" section
6. **Enhance**: Add visual examples, accessibility notes, real usage context
7. **Validate**: Run through checklist, create PR

### Using GitHub Copilot Spaces
1. **Open component file**: ComponentName.tsx
2. **Open Copilot Spaces**: Ctrl+Shift+.
3. **Use standard prompt**: See "Standard Prompt for GitHub Copilot Spaces" section
4. **Enhance**: Add visual examples, accessibility notes
5. **Validate**: Run through checklist, create PR

**Recommendation**: Start with GitHub Copilot Spaces if available (easier, better workspace context). Fall back to VS Code Copilot for focused tasks.

**Now read the detailed guide for best practices...**

---

## The Complete Process (Step-by-Step)

### Step 1: Identify the Component to Document (2 minutes)

**Start with components that are**:
- ‚úÖ Reusable across multiple pages (Button, Card, Table, Modal)
- ‚úÖ Business-critical (enrollment forms, course catalogs)
- ‚úÖ Complex behavior (controlled inputs, data tables, async operations)
- ‚úÖ Frequently modified (high churn = needs documentation)

**Skip components that are**:
- ‚ùå Trivial wrappers with no logic (just styling)
- ‚ùå One-off page-specific components (unless very complex)
- ‚ùå Auto-generated by tools (form builders, code generators)

**Example prioritization**:
```
Priority 1 (document first):
- Button, Input, Select, TextArea (form controls)
- Card, Table, Modal, Drawer (layout components)
- ErrorBoundary, LoadingSpinner (infrastructure)

Priority 2 (document when time permits):
- CourseCard, EnrollmentRow, UserProfile (domain components)
- Header, Sidebar, Footer (layout containers)

Priority 3 (document only if complex):
- Icon, Avatar, Badge (simple presentational)
- Page components (unless they have complex business logic)
```

---

### Step 2: Gather Required Files (5 minutes)

This is **critical** for Copilot quality. The more context you provide, the better the output.

#### File Selection Strategy

Choose a strategy based on your project structure:

---

#### **Strategy A: Standard React Project** (Most Common)

Use this if your project follows standard naming conventions and folder structure.

**Priority 1 - MUST ATTACH** (Core context):
```
‚úÖ Component implementation
   üìÅ src/components/common/Button.tsx

‚úÖ Component styles (if using CSS Modules)
   üìÅ src/components/common/Button.module.css

‚úÖ Props interface (if in separate file)
   üìÅ src/types/ButtonProps.ts
   
‚úÖ Template file
   üìÅ AKR files/ui_component_template.md
```

**Priority 2 - SHOULD ATTACH** (Rich context):
```
‚úÖ Component tests (shows usage patterns)
   üìÅ src/components/common/Button.test.tsx

‚úÖ Parent component that uses this component
   üìÅ src/components/forms/EnrollmentForm.tsx
   (Shows real-world usage)

‚úÖ Storybook stories (if available)
   üìÅ src/components/common/Button.stories.tsx
   (Shows all variants and states)

‚úÖ Related components
   üìÅ src/components/common/Input.tsx
   (For "Related Components" section)
```

**Priority 3 - NICE TO HAVE** (Optional enhancements):
```
‚úÖ Custom hooks used by component
   üìÅ src/hooks/useForm.ts

‚úÖ API services called by component
   üìÅ src/services/courseService.ts

‚úÖ Design system documentation
   üìÅ docs/design-system/button-spec.md
```

**Example attachment list for Button component**:
```
Required (P1):
- src/components/common/Button.tsx
- src/components/common/Button.module.css
- AKR files/ui_component_template.md

Recommended (P2):
- src/components/common/Button.test.tsx
- src/components/forms/EnrollmentForm.tsx (usage example)

Optional (P3):
- src/components/common/Input.tsx (related component)
```

---

#### **Strategy B: Feature-Based Architecture**

Use this if components are organized by feature/domain:

```
src/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ courses/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CourseCard.tsx          ‚Üê Document this
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CourseCard.module.css   ‚Üê Attach
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CourseCard.test.tsx     ‚Üê Attach
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useCourses.ts           ‚Üê Attach (if component uses it)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ courseService.ts        ‚Üê Attach (if component calls it)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Course.ts                ‚Üê Attach (data model)
```

**Attach files from the same feature folder first**, then common components:

**Priority 1**:
- Feature component + styles + tests
- Feature types (data models)
- Template

**Priority 2**:
- Feature hooks used by component
- Feature services called by component
- Common components used by this component

**Priority 3**:
- Parent page that uses this component
- Related feature components

---

#### **Strategy C: Monorepo with Design System**

Use this if you have a separate design system package:

```
packages/
‚îú‚îÄ‚îÄ design-system/
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îî‚îÄ‚îÄ Button/
‚îÇ           ‚îú‚îÄ‚îÄ Button.tsx              ‚Üê Document this
‚îÇ           ‚îú‚îÄ‚îÄ Button.module.css       ‚Üê Attach
‚îÇ           ‚îú‚îÄ‚îÄ Button.test.tsx         ‚Üê Attach
‚îÇ           ‚îú‚îÄ‚îÄ Button.stories.tsx      ‚Üê Attach
‚îÇ           ‚îî‚îÄ‚îÄ Button.types.ts         ‚Üê Attach
‚îî‚îÄ‚îÄ app/
    ‚îî‚îÄ‚îÄ src/
        ‚îî‚îÄ‚îÄ pages/
            ‚îî‚îÄ‚îÄ CourseCatalog.tsx       ‚Üê Attach (usage example)
```

**Priority 1**:
- All files in component folder (implementation, styles, types, tests, stories)
- Template

**Priority 2**:
- Usage examples from main app
- Design tokens file (if exists)
- Parent design system components

**Priority 3**:
- Design specifications (Figma links in separate doc)
- Accessibility audit results

---

### Step 3A: Use VS Code with Copilot (10 minutes)

#### 3A.1: Prepare Your Workspace

Before you start with Copilot:

1. **Copy the template**:
   ```powershell
   # From project root
   Copy-Item "AKR files/ui_component_template.md" `
             "docs/components/Button_doc.md"
   ```

2. **Open files in VS Code**:
   - Open template file (Button_doc.md)
   - Open component file (Button.tsx)
   - Open test file (Button.test.tsx) - if exists
   - Open usage example (EnrollmentForm.tsx) - if available

3. **Verify component is working**:
   - Run tests: `npm test Button`
   - Check Storybook (if available): `npm run storybook`
   - Or manually test in browser

4. **Open Copilot Chat**:
   - Press `Ctrl+Shift+I` (Windows/Linux) or `Cmd+Shift+I` (Mac)
   - Copilot Chat panel opens on the right side

5. **Attach files using @ mentions**:
   ```
   Type @ in the chat box ‚Üí File picker appears ‚Üí Select files
   ```
   
   **Recommended attachments**:
   ```
   @ui_component_template.md        ‚Üê Template (MUST)
   @Button.tsx                      ‚Üê Component implementation (MUST)
   @Button.module.css               ‚Üê Styles (SHOULD)
   @Button.test.tsx                 ‚Üê Tests (SHOULD)
   @EnrollmentForm.tsx              ‚Üê Usage example (OPTIONAL)
   ```

---

#### 3A.2: Standard Prompt for VS Code

**For Copilot Chat**, use this prompt:

```
Document this React component using the ui_component_template.md file I've attached.

Component to document: [ComponentName].tsx

Please:
1. Fill in all ü§ñ (AI-generated) sections based on the component code
2. Extract props from TypeScript interface into the Props API table
3. Generate usage examples from the test file and parent components
4. Document all visual states and variants from the implementation
5. Extract ARIA attributes and accessibility features
6. Leave all ‚ùì (human input needed) sections for me to fill in
7. Use the exact structure from the template

Focus on:
- Props API (complete table with types, defaults, descriptions)
- Visual states (default, hover, active, disabled, loading, error, focus)
- Usage examples (at least 3: basic, with state, with API)
- Component behavior (controlled vs uncontrolled, side effects)
- Accessibility (ARIA attributes, keyboard support)

Attached files for context:
- [ComponentName].tsx (implementation)
- [ComponentName].module.css (styles)
- [ComponentName].test.tsx (tests showing usage)
- [ParentComponent].tsx (real-world usage)
- ui_component_template.md (template to follow)
```

**Example for Button component**:
```
Document this React component using the ui_component_template.md file I've attached.

Component to document: Button.tsx

Please:
1. Fill in all ü§ñ sections based on the Button.tsx code
2. Extract ButtonProps interface into Props API table
3. Generate examples from Button.test.tsx
4. Document all 3 variants (primary, secondary, danger)
5. Extract aria-busy and aria-label usage
6. Leave ‚ùì sections for me to fill in
7. Keep the exact template structure

Focus on:
- Props API (variant, size, loading, disabled, onClick, children)
- Visual states (default, hover, active, disabled, loading, focus)
- Usage examples (basic button, with loading state, icon button)
- Accessibility (aria-busy when loading, aria-label for icons)

Attached:
- Button.tsx
- Button.module.css
- Button.test.tsx
- EnrollmentForm.tsx (shows real usage)
- ui_component_template.md
```

---

### Step 3B: Use GitHub Copilot Spaces (Alternative) (10 minutes)

#### 3B.1: Open Copilot Spaces

**In VS Code:**
1. Open the component file (e.g., `Button.tsx`)
2. Press `Ctrl+Shift+.` or click Copilot Spaces icon
3. Copilot Spaces panel opens

**GitHub Copilot Spaces has more workspace context automatically**, so you don't need to attach files manually. It can see:
- ‚úÖ All files in your workspace
- ‚úÖ Related components, hooks, services
- ‚úÖ Test files and usage examples
- ‚úÖ Project structure and existing documentation

---

#### 3B.2: Standard Prompt for GitHub Copilot Spaces

Copy the prompt below and paste into Copilot Spaces:

```
I need to document the [COMPONENT_NAME] component following our AKR documentation system.

**Context**:
- Template: Use ui_component_template.md from AKR files folder
- Conventions: Follow AKR_CHARTER.md and AKR_CHARTER_UI.md
- Target component: [COMPONENT_NAME] (file: [PATH_TO_COMPONENT])
- Output location: docs/components/[ComponentName]_doc.md

**Generate documentation with all template sections**:
1. **Component identification**: File path, type, complexity, last updated
2. **Quick Reference**: What it does, when to use, when NOT to use, accessibility, status
3. **Purpose & Context**: What component does, when to use it, when NOT to use it
4. **Props API**: Complete table with all props (name, type, required, default, description)
5. **Visual States & Variants**: All visual states (default, hover, active, disabled, loading, error, focus)
6. **Component Behavior**: User interactions, state management (controlled/uncontrolled), side effects
7. **Styling & Theming**: CSS classes, design tokens, customization methods
8. **Accessibility**: WCAG compliance, ARIA attributes, keyboard support, screen reader behavior
9. **Usage Examples**: At least 3-5 realistic examples (basic, with state, with API, composition, advanced)
10. **Component Architecture**: Dependencies, consumers, related components

**Critical conventions to follow**:
‚úÖ Mark AI-generated content with ü§ñ
‚úÖ Mark sections needing human input with ‚ùì
‚úÖ Extract props from TypeScript interface into Props API table
‚úÖ Document all variants from union types ('primary' | 'secondary' | 'danger')
‚úÖ Extract ARIA attributes from JSX
‚úÖ Focus on WHAT (observable from code) - mark ü§ñ
‚úÖ Flag WHY questions (business context, UX rationale) - mark ‚ùì

**What to extract from code**:
- Props from TypeScript interface (ButtonProps, etc.)
- Variants from union types
- CSS classes from className expressions
- ARIA attributes from JSX
- Event handlers (onClick, onChange, etc.)
- State hooks (useState, useEffect, etc.)
- Conditional rendering logic
- Default prop values

**What to flag for human input**:
- ‚ùì Visual appearance descriptions (what does it look like?)
- ‚ùì UX rationale (why this interaction pattern?)
- ‚ùì Business context (why was this component created?)
- ‚ùì Accessibility testing results (tested with NVDA?)
- ‚ùì Performance considerations (render time measurements)
- ‚ùì Browser compatibility issues (Safari bugs, etc.)
- ‚ùì Design decisions (why these specific variants?)

**Props API table format**:
| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| ü§ñ `propName` | `string` | Yes/No | `'value'` | ü§ñ Purpose of prop |

**Example usage format**:
```tsx
import { ComponentName } from '@/components/[path]/ComponentName';

function Example() {
  return (
    <ComponentName
      prop="value"
      onAction={handleAction}
    >
      Content
    </ComponentName>
  );
}
```

Generate complete documentation following this structure.
```

**Customization points**:
- Replace `[COMPONENT_NAME]` with actual component name (e.g., `Button`)
- Replace `[PATH_TO_COMPONENT]` with file path (e.g., `src/components/common/Button.tsx`)

---

#### What Copilot Should Generate

**Copilot is excellent at**:
- ‚úÖ Extracting props from TypeScript interfaces
- ‚úÖ Generating props table with types and defaults
- ‚úÖ Identifying variants from union types (`'primary' | 'secondary' | 'danger'`)
- ‚úÖ Listing imported dependencies
- ‚úÖ Extracting ARIA attributes from JSX
- ‚úÖ Generating basic code examples
- ‚úÖ Documenting component structure (hooks, state, effects)

**Copilot struggles with**:
- ‚ùå Visual descriptions ("what does it look like?")
- ‚ùå UX rationale ("why this interaction pattern?")
- ‚ùå Accessibility testing ("tested with NVDA?")
- ‚ùå Business context ("why was this component created?")
- ‚ùå Performance measurements ("render time: X ms")
- ‚ùå Browser compatibility issues ("Safari bug with...")

**Your job**: Fill in what Copilot can't.

---

### Step 4: Key Differences - VS Code/Copilot vs GitHub Spaces

| Aspect | VS Code with Copilot | GitHub Copilot Spaces |
|--------|----------------------|------------------------|
| **Context** | Manual file attachment (@mentions) | Automatic workspace awareness |
| **File limit** | ~5 files (token limit) | Entire workspace accessible |
| **Setup** | More manual (attach files, copy template) | Less setup (workspace aware) |
| **Prompt style** | Explicit file references needed | Can reference by description |
| **Best for** | Focused documentation tasks | Broader context understanding |
| **Output quality** | High (if right files attached) | High (better cross-component insights) |
| **Learning curve** | Low (file picker straightforward) | Medium (need to understand Spaces) |

**Recommendation**: 
- **Start with GitHub Copilot Spaces** if available (easier, better context, sees usage patterns)
- **Fall back to VS Code Copilot** if Spaces not available or for simple components

---

### Step 5: Review and Correct AI Output (3 minutes)

Check the AI-generated content for common mistakes:

#### Props API Table

**Check**:
- [ ] All props from interface are documented
- [ ] Types are accurate (check union types, complex types)
- [ ] Required vs optional is correct (`?` in interface = optional)
- [ ] Default values match implementation
- [ ] Descriptions are clear and actionable

**Common AI mistakes**:
```typescript
// Interface:
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  loading?: boolean;
  onClick?: () => void;
  children: React.ReactNode;
}

// ‚ùå AI might say variant is required (it's optional)
// ‚ùå AI might omit default value for variant
// ‚ùå AI might incorrectly describe onClick callback

// ‚úÖ Correct documentation:
| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `variant` | `'primary' \| 'secondary' \| 'danger'` | No | `'primary'` | Visual style variant |
| `loading` | `boolean` | No | `false` | Shows loading spinner, disables button |
| `onClick` | `() => void` | No | - | Called when button is clicked |
| `children` | `React.ReactNode` | Yes | - | Button label or content |
```

---

#### Visual States

**Check**:
- [ ] All states are documented (default, hover, active, disabled, loading, error, focus)
- [ ] CSS classes are correctly identified
- [ ] Conditional rendering is captured

**Example**:
```tsx
// Component code:
<button
  className={`${styles.btn} ${styles[variant]} ${loading ? styles.loading : ''}`}
  disabled={disabled || loading}
  aria-busy={loading}
>
  {loading && <Spinner />}
  {children}
</button>

// ‚úÖ Document:
// - Default state: styles.btn + styles.primary
// - Loading state: + styles.loading, disabled=true, aria-busy=true, shows Spinner
// - Disabled state: disabled=true, not clickable
```

---

#### Usage Examples

**Check**:
- [ ] Examples are realistic (not contrived)
- [ ] Examples show different use cases
- [ ] Code is syntactically correct
- [ ] Imports are included

**Common AI mistakes**:
```tsx
// ‚ùå AI might generate incomplete example
<Button onClick={handleClick}>
  Click me
</Button>
// Missing: What is handleClick? Is it imported? Defined?

// ‚úÖ Better example
import { Button } from '@/components/common/Button';

function EnrollmentForm() {
  const handleSubmit = () => {
    console.log('Form submitted');
  };
  
  return (
    <Button variant="primary" onClick={handleSubmit}>
      Enroll Now
    </Button>
  );
}
```

---

### Step 6: Enhance with Human Context (10 minutes)

Now fill in the ‚ùì sections that AI can't generate:

#### 6.1 Visual Examples and Descriptions

**Add visual descriptions** for each variant and state:

```markdown
### Example 1: Variants

```tsx
<Button variant="primary">Save</Button>
<Button variant="secondary">Cancel</Button>
<Button variant="danger">Delete</Button>
```

**Renders**: Three buttons side-by-side:
- ‚ùì "Save" (blue background #007bff, white text, rounded corners)
- ‚ùì "Cancel" (white background, blue border, blue text)
- ‚ùì "Delete" (red background #dc3545, white text, rounded corners)

**Screenshot**: See `docs/screenshots/button-variants.png`
```

**Pro tip**: Take actual screenshots or reference Storybook stories.

---

#### 6.2 Business Context and UX Rationale

**Add why** the component exists and design decisions:

```markdown
## Purpose & Context

### What This Component Does

ü§ñ A reusable button component with multiple variants for different action types.

‚ùì **Business Context**:
Created to standardize button styles across the Training Tracker application. 
Before this component, buttons had inconsistent styling and accessibility issues.
This component ensures:
- Consistent visual design (follows Emerson Design System)
- Proper loading states for async operations (prevents double-clicks)
- Accessibility compliance (keyboard nav, screen readers)
- Type safety with TypeScript

‚ùì **Design Decisions**:
- Three variants chosen to match common action types:
  - Primary: Main call-to-action (enroll, save, submit)
  - Secondary: Alternative actions (cancel, back)
  - Danger: Destructive actions (delete, remove)
- Loading state built-in to prevent double-submission bugs
- Extends HTML button attributes for flexibility
```

---

#### 6.3 Accessibility Testing Results

**Document real accessibility testing**:

```markdown
## Accessibility

### Screen Reader Testing

‚ùì **Tested with**:
- [x] NVDA 2023.1 (Windows 11)
- [x] JAWS 2023 (Windows 11)
- [x] VoiceOver (macOS Sonoma)
- [ ] VoiceOver (iOS) - Not tested yet
- [ ] TalkBack (Android) - Not tested yet

‚ùì **Default state announces**:
```
"Save, button"
```

‚ùì **Loading state announces**:
```
"Save, button, busy"
[Every 5 seconds: "Still loading..."]
```

‚ùì **Disabled state announces**:
```
"Save, button, dimmed" (NVDA)
"Save, button, unavailable" (JAWS)
```

‚ùì **Issues found**:
- None with NVDA/JAWS
- VoiceOver on macOS: Loading state announces correctly
- **Action needed**: Test on iOS/Android before mobile launch
```

**Pro tip**: Actually test with screen readers. It takes 10 minutes and catches real issues.

---

#### 6.4 Real-World Usage Context

**Show where component is used in the app**:

```markdown
### Consumers (Where This Component Is Used)

ü§ñ **Used in**:
- `EnrollmentForm.tsx`
- `CourseCard.tsx`
- `AdminPanel.tsx`

‚ùì **Real Usage Context**:

**1. Enrollment Form** (most common usage)
- Primary button: "Enroll Now" (submits enrollment)
- Secondary button: "Cancel" (closes form)
- Loading state: Shows while API call in progress

**2. Course Card** (list views)
- Primary button: "View Details" (navigates to course page)
- Shows loading state when fetching course details

**3. Admin Panel** (administrative actions)
- Danger button: "Delete User" (shows confirmation modal first)
- Primary button: "Save Changes" (updates user profile)

**4. Known Usage Patterns**:
- Always use `loading` prop during API calls (prevents double-submission)
- Always use `variant="danger"` for delete actions (visual warning)
- Icon-only buttons MUST include `aria-label` (accessibility requirement)
```

---

#### 6.5 Performance Measurements

**Add real performance data**:

```markdown
## Performance Considerations

### Rendering Performance

‚ùì **Measured with React DevTools Profiler** (Chrome 119, 100 renders):
- **Typical render time**: 0.8ms (median)
- **95th percentile**: 1.2ms
- **Max render time**: 3.1ms (outlier, during page load)
- **Re-render frequency**: Low (only when props change)

‚ùì **Bundle size** (measured with webpack-bundle-analyzer):
- Component code: 2.1 KB (minified)
- CSS Modules: 0.8 KB (minified)
- Total: 2.9 KB (gzipped: 1.1 KB)

‚ùì **Optimization applied**:
- ‚úÖ React.memo: Not needed (simple component, fast render)
- ‚úÖ useCallback: Not needed (no child components re-rendering)
- ‚úÖ CSS Modules: Scoped styles, no global CSS pollution

‚ùì **Bottlenecks**: None identified. Component is lightweight and fast.
```

---

#### 6.6 Known Issues and Browser Testing

**Document real issues found during testing**:

```markdown
## Known Issues & Limitations

### Known Issues

| Issue | Impact | Workaround | Tracking |
|-------|--------|------------|----------|
| ‚ùì Safari 14: Focus outline not visible on click | Low - keyboard users see outline | Use `:focus-visible` instead of `:focus` | Ticket #456 |
| ‚ùì IE11: CSS Grid not supported | N/A - IE11 not supported | None | N/A |

### Browser Compatibility

‚ùì **Tested on**:

| Browser | Version | Support Level | Known Issues |
|---------|---------|---------------|--------------|
| ‚úÖ Chrome | 119+ | ‚úÖ Full | None |
| ‚úÖ Firefox | 120+ | ‚úÖ Full | None |
| ‚úÖ Safari | 17+ | ‚úÖ Full | None |
| ‚úÖ Edge | 119+ | ‚úÖ Full | None |
| ‚ö†Ô∏è Safari | 14-16 | ‚ö†Ô∏è Partial | Focus outline issue (low impact) |
| ‚ùå IE 11 | - | ‚ùå Not supported | CSS Grid not supported |

‚ùì **Testing environment**:
- Windows 11 (Chrome, Edge, Firefox)
- macOS Sonoma (Safari, Chrome)
- Not tested on mobile browsers yet

### Limitations

‚ùì **This component does NOT**:
- Support icon-only buttons without `aria-label` (will fail accessibility)
- Support custom loading spinners (uses built-in spinner)
- Support button groups (use `ButtonGroup` component instead)
- Support tooltips (use `Tooltip` wrapper component)

‚ùì **Planned enhancements**:
- Add `size` prop: 'small' | 'medium' | 'large' - Ticket #789
- Add `icon` prop for leading/trailing icons - Ticket #790
- Add `fullWidth` prop for block-level buttons - Ticket #791
```

---

### Step 7: Fill Questions & Gaps Section (2 minutes)

Use this section **during documentation** to track what you don't know:

```markdown
## Questions & Gaps

### Unanswered Questions

- ‚ùì **Q**: Should this button support icon-only variants?
  - **Ask**: UX team (Jane Doe)
  - **Deadline**: Before v2.0 release

- ‚ùì **Q**: What's the maximum button text length before wrapping?
  - **Test**: Create example with long text
  - **Document**: Add to "Limitations" section

- ‚ùì **Q**: Is this component used in mobile app?
  - **Ask**: Mobile team (John Smith)
  - **Action**: If yes, add mobile-specific docs

### Documentation Gaps

- ‚ùì **Gap**: Missing Storybook stories for all variants
  - **Action**: Create Button.stories.tsx
  - **Owner**: You
  - **Deadline**: This sprint

- ‚ùì **Gap**: No visual regression tests
  - **Action**: Set up Chromatic, add snapshots
  - **Owner**: QA team
  - **Deadline**: Next sprint

- ‚ùì **Gap**: Screen reader testing incomplete (iOS/Android not tested)
  - **Action**: Test with VoiceOver (iOS) and TalkBack (Android)
  - **Owner**: Accessibility team
  - **Deadline**: Before mobile launch

### Technical Debt

- ‚ùì **Debt**: CSS Modules use magic numbers for spacing
  - **Refactor**: Extract to design tokens
  - **Ticket**: #892
  - **Priority**: Low

- ‚ùì **Debt**: No TypeScript generics for polymorphic "as" prop
  - **Example**: `<Button as="a" href="...">`
  - **Ticket**: #893
  - **Priority**: Medium
```

**Pro tip**: Don't delete this section after documentation is complete. Use it to track ongoing improvements.

---

### Step 8: Final Validation (3 minutes)

Run through this checklist before creating PR:

#### Documentation Completeness Checklist

**Essential sections (must be complete)**:
- [ ] Component name, file path, type, complexity filled in
- [ ] Quick Reference has 1-sentence description and basic example
- [ ] Purpose & Context explains what/when/when not
- [ ] Props API table has all props with types, required, defaults, descriptions
- [ ] At least 1 usage example (preferably 3+)
- [ ] Visual states documented (at least default, hover, disabled)
- [ ] Accessibility section has ARIA attributes and keyboard support
- [ ] Related Documentation links are correct

**Quality checks**:
- [ ] All ü§ñ sections filled in (no placeholder text)
- [ ] ‚ùì sections enhanced with human context
- [ ] Code examples are syntactically correct
- [ ] Code examples have imports and context
- [ ] Props table matches TypeScript interface exactly
- [ ] No obvious typos or formatting issues

**Cross-references**:
- [ ] Links to related components work
- [ ] Links to backend API docs work (if component calls APIs)
- [ ] Links to design system work (if applicable)
- [ ] Links to Figma work (if applicable)

**Metadata**:
- [ ] Last Updated date is today
- [ ] Author name is your name
- [ ] Version history has at least 1.0.0 entry

---

#### Testing the Documentation

**Read as if you're a new developer**:
1. Can you understand what the component does? (Purpose)
2. Can you copy-paste examples and get working code? (Examples)
3. Can you figure out all props without reading the code? (Props API)
4. Can you handle edge cases? (Error handling, limitations)
5. Can you make it accessible? (Accessibility section)

**If answer is "no" to any question**, enhance that section.

---

## Common Scenarios and Solutions

### Scenario 1: Component with Many Props (10+ props)

**Problem**: Props table becomes overwhelming.

**Solution**: Group props by category.

```markdown
## Props API

### Layout Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `width` | `string \| number` | No | `'auto'` | Component width |
| `height` | `string \| number` | No | `'auto'` | Component height |
| `padding` | `string \| number` | No | `0` | Internal padding |

### Style Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `variant` | `'primary' \| 'secondary'` | No | `'primary'` | Visual style |
| `color` | `string` | No | - | Custom color |

### Behavior Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `loading` | `boolean` | No | `false` | Shows loading state |
| `disabled` | `boolean` | No | `false` | Disables interaction |

### Event Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `onClick` | `() => void` | No | - | Click handler |
| `onHover` | `() => void` | No | - | Hover handler |
```

---

### Scenario 2: Component with Generic Types

**Problem**: Component uses TypeScript generics.

**Example**:
```typescript
interface TableProps<T> {
  data: T[];
  columns: ColumnDef<T>[];
  onRowClick?: (row: T) => void;
}
```

**Solution**: Document generic parameter first, then props.

```markdown
## Props API

### Generic Type Parameters

| Parameter | Constraint | Description |
|-----------|------------|-------------|
| `T` | `object` | Type of data items in the table |

### Props Table

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `data` | `T[]` | Yes | - | Array of data items to display |
| `columns` | `ColumnDef<T>[]` | Yes | - | Column definitions |
| `onRowClick` | `(row: T) => void` | No | - | Called when row is clicked |

### Usage with Generic Types

```tsx
// Example 1: Table with Course data
interface Course {
  id: string;
  title: string;
  instructor: string;
}

<Table<Course>
  data={courses}
  columns={courseColumns}
  onRowClick={(course) => console.log(course.title)}
/>

// Example 2: Table with User data
interface User {
  id: string;
  name: string;
  email: string;
}

<Table<User>
  data={users}
  columns={userColumns}
  onRowClick={(user) => console.log(user.email)}
/>
```
```

---

### Scenario 3: Compound Components (Composition Pattern)

**Problem**: Component has sub-components (Card.Header, Card.Body, Card.Footer).

**Solution**: Document parent and sub-components separately.

```markdown
## Component Composition

This component follows the **Compound Component** pattern with sub-components:

```tsx
import { Card } from '@/components/common/Card';

<Card>
  <Card.Header>Header content</Card.Header>
  <Card.Body>Body content</Card.Body>
  <Card.Footer>Footer content</Card.Footer>
</Card>
```

### Parent Component: `Card`

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `variant` | `'default' \| 'bordered'` | No | `'default'` | Card style |
| `children` | `React.ReactNode` | Yes | - | Card content (use sub-components) |

### Sub-Component: `Card.Header`

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `children` | `React.ReactNode` | Yes | - | Header content |
| `className` | `string` | No | `''` | Additional CSS classes |

### Sub-Component: `Card.Body`

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `children` | `React.ReactNode` | Yes | - | Body content |
| `padding` | `'none' \| 'small' \| 'medium' \| 'large'` | No | `'medium'` | Internal padding |

### Sub-Component: `Card.Footer`

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `children` | `React.ReactNode` | Yes | - | Footer content (typically buttons) |
| `align` | `'left' \| 'center' \| 'right'` | No | `'right'` | Content alignment |

### Composition Benefits

- ‚úÖ Flexible structure (use only parts you need)
- ‚úÖ Clear visual hierarchy in code
- ‚úÖ Easy to extend (add new sub-components)
- ‚úÖ Type-safe (TypeScript validates sub-component props)
```

---

### Scenario 4: Component That Calls Backend APIs

**Problem**: Component fetches data, needs to document API integration.

**Solution**: Link to backend API docs, document data flow.

```markdown
## Data Fetching

This component fetches data from the backend API.

### API Endpoints Used

| Endpoint | Method | Purpose | Documentation |
|----------|--------|---------|---------------|
| `/api/courses` | GET | Fetch course list | [API Docs](../../api-repo/docs/endpoints/courses.md) |
| `/api/courses/{id}` | GET | Fetch course details | [API Docs](../../api-repo/docs/endpoints/courses.md#get-course-by-id) |

### Service Layer

API calls handled by `courseService.ts`:
- See [courseService documentation](../services/courseService_doc.md)

### Data Flow

```
Component Mount
    ‚Üì
useEffect triggers
    ‚Üì
courseService.fetchCourses()
    ‚Üì
API call: GET /api/courses
    ‚Üì
Response: Course[]
    ‚Üì
setState(courses)
    ‚Üì
Component re-renders with data
```

### Error Handling

| Error Type | User Experience | Developer Action |
|------------|-----------------|------------------|
| **Network Error** | "Failed to load courses. Try again." with retry button | Logged to console, user can retry |
| **API Error (401)** | Redirect to login page | Token expired, re-authenticate |
| **API Error (404)** | "Course not found" message | Show error state, log to monitoring |
| **API Error (500)** | "Server error. Contact support." | Log to Sentry, show error state |

### Loading States

| State | UI Display | When |
|-------|------------|------|
| **Initial Load** | Skeleton loader | First API call |
| **Refresh** | Spinner overlay | Manual refresh |
| **Pagination** | Loading indicator in footer | Loading next page |
| **Empty** | "No courses found" empty state | API returns empty array |

### Data Models

| Model | Source | Documentation |
|-------|--------|---------------|
| `Course` | Backend API | [Course entity](../../api-repo/docs/models/Course.md) |
| `Enrollment` | Backend API | [Enrollment entity](../../api-repo/docs/models/Enrollment.md) |

### Caching

- **Cache key**: `courses-${userId}`
- **Cache duration**: 5 minutes
- **Cache library**: React Query
- **Invalidation**: On course create/update/delete
```

---

### Scenario 5: Higher-Order Component (HOC)

**Problem**: Component wraps other components (withAuth, withLoading).

**Solution**: Document HOC pattern, show before/after examples.

```markdown
# HOC: withAuth

**File**: `src/hocs/withAuth.tsx`  
**Type**: Higher-Order Component  
**Purpose**: Adds authentication check to any component

---

## What This HOC Does

Wraps a component to require authentication. If user is not authenticated, redirects to login page.

## Usage

### Basic Usage

```tsx
import { withAuth } from '@/hocs/withAuth';

function DashboardPage() {
  return <div>Protected Dashboard Content</div>;
}

// Wrap component with HOC
export default withAuth(DashboardPage);
```

### Before and After

**Before** (without HOC):
```tsx
// ‚ùå No authentication check
function DashboardPage() {
  return <div>Dashboard</div>;
}
```

**After** (with HOC):
```tsx
// ‚úÖ Authentication check added
const ProtectedDashboard = withAuth(DashboardPage);

// User not authenticated ‚Üí redirects to /login
// User authenticated ‚Üí renders DashboardPage
```

## API

### Function Signature

```typescript
function withAuth<P extends object>(
  Component: React.ComponentType<P>
): React.FC<P>
```

### Type Parameters

| Parameter | Constraint | Description |
|-----------|------------|-------------|
| `P` | `object` | Props type of wrapped component |

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `Component` | `React.ComponentType<P>` | Component to wrap |

### Return Value

Returns a new component with authentication logic.

## Behavior

### Authentication Flow

```
Component renders
    ‚Üì
Check useAuth().isAuthenticated
    ‚Üì
Not authenticated?
    ‚Üì
Redirect to /login
    ‚Üì
Authenticated?
    ‚Üì
Render wrapped component
```

### Props Forwarding

All props passed to HOC are forwarded to wrapped component:

```tsx
const ProtectedDashboard = withAuth(DashboardPage);

<ProtectedDashboard userId="123" />
// DashboardPage receives: userId="123"
```

## Examples

### Example 1: Protect Admin Page

```tsx
function AdminPanel() {
  return <div>Admin Controls</div>;
}

export default withAuth(AdminPanel);
```

### Example 2: Protect Route

```tsx
// In router config
<Route path="/dashboard" element={withAuth(Dashboard)} />
<Route path="/admin" element={withAuth(AdminPanel)} />
<Route path="/login" element={<LoginPage />} />
```

### Example 3: Conditional Protection

```tsx
// Protect based on role
function withAuthRole(Component, requiredRole) {
  return withAuth((props) => {
    const { user } = useAuth();
    
    if (user.role !== requiredRole) {
      return <Navigate to="/unauthorized" />;
    }
    
    return <Component {...props} />;
  });
}

// Usage
const AdminOnlyPanel = withAuthRole(AdminPanel, 'admin');
```

## Implementation Details

```typescript
export function withAuth<P extends object>(
  Component: React.ComponentType<P>
): React.FC<P> {
  return function AuthenticatedComponent(props: P) {
    const { isAuthenticated, isLoading } = useAuth();
    
    if (isLoading) {
      return <LoadingSpinner />;
    }
    
    if (!isAuthenticated) {
      return <Navigate to="/login" />;
    }
    
    return <Component {...props} />;
  };
}
```

## Alternative: Custom Hook

Instead of HOC, you can use a custom hook:

```tsx
// Hook approach
function DashboardPage() {
  useRequireAuth(); // Hook handles redirect
  
  return <div>Dashboard</div>;
}

// vs HOC approach
const DashboardPage = withAuth(() => {
  return <div>Dashboard</div>;
});
```

**When to use HOC vs Hook**:
- **HOC**: Need to wrap many components consistently
- **Hook**: Need more control over authentication logic
```

---

## Time-Saving Tips

### Tip 1: Reuse Documentation Across Similar Components

If you have multiple similar components (Button, IconButton, LinkButton):

1. Document the most complex one first (Button)
2. Copy documentation to similar components
3. Use find-replace to update component name
4. Remove sections that don't apply
5. Add unique features

**Time saved**: 10-15 minutes per similar component

---

### Tip 2: Extract Patterns to Shared Documentation

If multiple components share patterns (all form inputs have validation):

1. Create shared doc: `docs/patterns/form-validation.md`
2. Link from each component:
   ```markdown
   ## Validation
   
   This component follows the standard form validation pattern.
   See [Form Validation Pattern](../../patterns/form-validation.md) for details.
   ```

**Time saved**: 5 minutes per component (no duplication)

---

### Tip 3: Use Storybook for Visual Documentation

If you have Storybook:

1. Create comprehensive stories (all variants, all states)
2. Link from documentation:
   ```markdown
   ## Visual Examples
   
   See [Button Storybook](http://localhost:6006/?path=/story/components-button--primary)
   for interactive examples of all variants and states.
   ```
3. Export Storybook to static site for permanent reference

**Time saved**: 10 minutes (no need to write visual descriptions)

---

### Tip 4: Generate Props Table from TypeScript

Use tools to auto-generate props table:

**Option 1: react-docgen**
```bash
npm install --save-dev react-docgen-typescript
npx react-docgen-typescript src/components/Button.tsx
```

**Option 2: TypeDoc**
```bash
npm install --save-dev typedoc
npx typedoc src/components/Button.tsx
```

**Copy output to documentation**, enhance with descriptions.

**Time saved**: 5 minutes (no manual typing)

---

### Tip 5: Batch Documentation Sessions

Instead of documenting one component at a time:

1. **Day 1**: Generate AI baseline for 5 components (10 min each = 50 min)
2. **Day 2**: Enhance all 5 with visual examples (10 min each = 50 min)
3. **Day 3**: Accessibility testing for all 5 (5 min each = 25 min)

**Benefits**:
- Stay in "documentation mode"
- Reuse context (same charters, templates, patterns)
- Faster Copilot responses (more context from previous components)

**Time saved**: 15-20 minutes per batch (efficiency gains)

---

## Troubleshooting

### Issue 1: Copilot Generated Incorrect Props Table

**Symptoms**:
- Props marked as required when they're optional
- Default values are wrong
- Types don't match interface

**Solution**:
1. Check TypeScript interface directly (don't trust AI)
2. Look for `?` in interface (optional prop)
3. Look for default values in component destructuring:
   ```typescript
   function Button({
     variant = 'primary',  // Default is 'primary'
     loading = false,       // Default is false
     disabled,              // No default (undefined)
     ...rest
   }: ButtonProps) {
   ```
4. Manually correct props table

---

### Issue 2: Copilot Missed Complex Behavior

**Symptoms**:
- State management logic not documented
- Side effects not mentioned
- Conditional rendering not explained

**Solution**:
1. Re-read component code carefully
2. Look for:
   - `useState`, `useEffect`, `useCallback` hooks
   - API calls (fetch, axios, service imports)
   - Conditional rendering (`{condition && <Component />}`)
   - Event handlers that modify state
3. Add "Component Behavior" section with detailed explanation

---

### Issue 3: Examples Don't Match Real Usage

**Symptoms**:
- Examples are too simple (no real-world context)
- Examples have syntax errors
- Examples don't show actual use cases

**Solution**:
1. Find real usages in codebase:
   ```powershell
   # Search for component imports
   code --search "import { Button }" --folder ./src
   ```
2. Copy real usage from parent components
3. Simplify if needed, but keep realistic context
4. Test examples in browser (copy-paste to test component)

---

### Issue 4: Don't Know Accessibility Requirements

**Symptoms**:
- Unsure which ARIA attributes are needed
- Don't know keyboard navigation expectations
- Haven't tested with screen readers

**Solution**:
1. Check WCAG guidelines: https://www.w3.org/WAI/WCAG21/quickref/
2. Use axe DevTools browser extension (free): https://www.deque.com/axe/devtools/
3. Test with screen reader:
   - Windows: NVDA (free) - https://www.nvaccess.org/download/
   - macOS: VoiceOver (built-in) - Cmd+F5 to enable
4. Copy patterns from similar components in established libraries (Material-UI, Chakra UI)

---

### Issue 5: Component Too Complex to Document

**Symptoms**:
- Component is 500+ lines
- Has 20+ props
- Multiple responsibilities
- Hard to explain

**Solution**:
1. **Consider refactoring first** (split into smaller components)
2. If refactoring not possible:
   - Use headings to break down sections
   - Group props by category
   - Create multiple examples (one per feature)
   - Link to related components
   - Document architecture diagram (ASCII or image)

**Example**:
```markdown
## Component Architecture

This component is complex. Here's the high-level structure:

```
CourseManager (main component)
‚îú‚îÄ‚îÄ CourseList (displays courses)
‚îÇ   ‚îî‚îÄ‚îÄ CourseCard (individual course)
‚îú‚îÄ‚îÄ CourseSearch (search/filter)
‚îú‚îÄ‚îÄ CoursePagination (pagination)
‚îî‚îÄ‚îÄ CourseActions (bulk actions)
```

**Responsibilities**:
1. Data fetching (courses from API)
2. Search and filtering
3. Pagination
4. Bulk actions (delete, export)

**See Also**:
- [CourseList documentation](./CourseList_doc.md)
- [CourseCard documentation](./CourseCard_doc.md)
```
```

---

## Quality Checklist (Final Review)

Before submitting PR, verify:

### Completeness
- [ ] All required sections filled in
- [ ] All ü§ñ sections generated by AI
- [ ] All ‚ùì sections enhanced by human
- [ ] At least 3 usage examples
- [ ] Props table matches TypeScript interface
- [ ] Visual states documented
- [ ] Accessibility section complete

### Accuracy
- [ ] Component name and file path correct
- [ ] Props types match implementation
- [ ] Required vs optional props correct
- [ ] Default values correct
- [ ] Code examples are syntactically correct
- [ ] Links to related docs work

### Quality
- [ ] Examples show real use cases (not contrived)
- [ ] Visual descriptions are clear
- [ ] Business context explains "why"
- [ ] Accessibility tested with screen reader
- [ ] Browser compatibility tested
- [ ] No placeholder text (TODO, TBD, etc.)

### Maintainability
- [ ] Last Updated date is today
- [ ] Author name filled in
- [ ] Version history has entry
- [ ] Questions & Gaps section filled in
- [ ] Known issues documented

---

## Creating the Pull Request

### PR Template for Component Documentation

```markdown
## Component Documentation: [ComponentName]

### Summary
Added comprehensive documentation for `[ComponentName]` component.

### Documentation Includes
- ‚úÖ Props API (X props documented)
- ‚úÖ Visual states (X states documented)
- ‚úÖ Usage examples (X examples)
- ‚úÖ Accessibility (WCAG Level AA, keyboard nav, screen reader tested)
- ‚úÖ Performance measurements
- ‚úÖ Browser compatibility testing

### Time Spent
- AI baseline generation: ~10 minutes
- Human enhancement: ~15 minutes
- **Total: ~25 minutes**

### Review Focus
Please review:
1. Props API table (verify types and defaults)
2. Usage examples (are they realistic?)
3. Accessibility section (any missing requirements?)

### Checklist
- [ ] All required sections complete
- [ ] Code examples tested
- [ ] Links to related docs work
- [ ] Follows AKR_CHARTER_UI.md conventions

### Related Issues
- Closes #[issue-number]
```

---

## FAQ

### Q1: How long should documentation be?

**A**: Baseline documentation is ~5-8 pages (ui_component_template.md is 21 KB). Simple components may be 3-4 pages, complex components may be 10-15 pages.

**Rule of thumb**: If documentation is longer than component code, you're over-documenting.

---

### Q2: Do I need to document every single prop?

**A**: Yes, document ALL props in the Props API table. But simple props can have brief descriptions:

```markdown
| `className` | `string` | No | `''` | Additional CSS classes |
```

Complex props need detailed explanation in separate section.

---

### Q3: Should I include screenshots or just text descriptions?

**A**: **Preferred**: Screenshots or Storybook links (visual proof)  
**Acceptable**: Detailed text descriptions (colors, layout, spacing)  
**Not enough**: "It looks good" (too vague)

If project has Storybook, always link to stories instead of duplicating visual info.

---

### Q4: What if component has no tests?

**A**: Document the Testing section anyway:

```markdown
## Testing

### Test Coverage

- **Test file**: ‚ùå No tests exist yet
- **Action needed**: Create `Button.test.tsx` with basic tests

### Recommended Test Cases

| Scenario | Test | Expected Result |
|----------|------|-----------------|
| **Render** | Renders with props | Component visible |
| **Click** | User clicks | `onClick` called |
| **Disabled** | `disabled={true}` | Button not clickable |

**Ticket**: #[ticket-number] - Add Button component tests
```

This documents the gap and provides guidance for future test creation.

---

### Q5: What if I don't know the business context?

**A**: Ask! Add to Questions & Gaps section:

```markdown
## Questions & Gaps

### Unanswered Questions

- ‚ùì **Q**: Why was this component created? What problem does it solve?
  - **Ask**: Original developer (Jane Doe)
  - **Ask**: Product Owner (John Smith)
  - **Status**: Pending response
```

Then update documentation later when you get answers.

---

### Q6: Should I document deprecated components?

**A**: Yes, but clearly mark as deprecated:

```markdown
# Component Documentation: OldButton

**Status**: ‚ö†Ô∏è **DEPRECATED** - Use `Button` component instead  
**Deprecation Date**: 2025-09-01  
**Removal Date**: 2026-01-01 (4 months)

---

## Migration Guide

### Migrate from OldButton to Button

```tsx
// Before (OldButton)
<OldButton type="primary" isLoading={true}>
  Click me
</OldButton>

// After (Button)
<Button variant="primary" loading={true}>
  Click me
</Button>
```

**Breaking changes**:
1. `type` prop ‚Üí renamed to `variant`
2. `isLoading` prop ‚Üí renamed to `loading`
3. Removed `size` prop (use `className` instead)
```

---

### Q7: How do I document a component that's still in development?

**A**: Use status markers:

```markdown
# Component Documentation: NewFeatureCard

**Status**: üöß **EXPERIMENTAL** - API may change  
**Since**: v0.5.0  
**Stable in**: v1.0.0 (planned)

‚ö†Ô∏è **Warning**: This component is under active development. Props and behavior may change without notice. Do not use in production yet.

---

## Known Limitations (will be fixed before v1.0)

- [ ] No error handling yet
- [ ] Performance not optimized
- [ ] Accessibility incomplete
- [ ] Browser compatibility not tested
```

---

### Q8: Can I skip sections that don't apply?

**A**: Yes, but explain why:

```markdown
## Performance Considerations

‚ùå **Not applicable**: This component renders once on page load and never updates. No performance optimization needed.
```

Or:

```markdown
## Browser Compatibility

‚úÖ **Fully compatible**: Component uses only standard HTML/CSS. No browser-specific features. No compatibility issues.
```

---

## Summary

**Documentation workflow**:
1. ‚è±Ô∏è **2 min** - Identify component, gather files
2. ‚è±Ô∏è **1 min** - Copy template, prepare workspace
3. ‚è±Ô∏è **10 min** - Use Copilot to generate baseline
4. ‚è±Ô∏è **3 min** - Review and correct AI output
5. ‚è±Ô∏è **10 min** - Enhance with human context
6. ‚è±Ô∏è **3 min** - Final validation and checklist

**Total: 20-30 minutes per component**

**Key success factors**:
- ‚úÖ Attach right files to Copilot (component + tests + usage)
- ‚úÖ Use standard prompt (copy-paste from this guide)
- ‚úÖ Always enhance AI output (don't just accept it)
- ‚úÖ Focus on visual examples and accessibility
- ‚úÖ Document "why" not just "what"

**Remember**: Good documentation helps developers **use** the component, not just understand the code. Focus on examples, behavior, and edge cases.

---

**Related Documentation**:
- [AKR_CHARTER_UI.md](./AKR_CHARTER_UI.md) - UI component conventions
- [ui_component_template.md](./ui_component_template.md) - Template to use
- [AKR_CHARTER.md](./AKR_CHARTER.md) - Universal principles

---

**UI Component Documentation Developer Guide - End of Document**

"""
Write Operations Module

Handles file writing operations for MCP documentation.
Provides tools for creating new documentation files and committing changes.
"""

import logging
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Optional

logger = logging.getLogger("akr-mcp-server.tools.write_operations")


class DocumentationWriter:
    """
    Handles writing documentation files to the repository.
    
    Features:
    - Creates documentation files at specified paths
    - Creates parent directories as needed
    - Commits changes with meaningful messages
    - Adds AI-generated markers to content
    """
    
    def __init__(self, repo_path: str):
        """
        Initialize documentation writer.
        
        Args:
            repo_path: Path to the repository
        """
        self.repo_path = Path(repo_path)
    
    def _run_git(self, *args) -> subprocess.CompletedProcess:
        """Run a git command in the repository."""
        cmd = ["git"] + list(args)
        return subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd=self.repo_path
        )
    
    def file_exists(self, file_path: str) -> bool:
        """Check if a file exists in the repository."""
        full_path = self.repo_path / file_path
        return full_path.exists()
    
    def read_file(self, file_path: str) -> Optional[str]:
        """Read contents of a file."""
        full_path = self.repo_path / file_path
        if not full_path.exists():
            return None
        
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Error reading file: {e}")
            return None
    
    def write_file(self, file_path: str, content: str, 
                   create_directories: bool = True) -> bool:
        """
        Write content to a file.
        
        Args:
            file_path: Relative path to the file
            content: Content to write
            create_directories: Create parent directories if needed
            
        Returns:
            True if successful
        """
        full_path = self.repo_path / file_path
        
        try:
            if create_directories:
                full_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.info(f"Wrote file: {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error writing file: {e}")
            return False
    
    def add_ai_header(self, content: str, source_file: str, 
                      component_type: str, template: str) -> str:
        """
        Add AI-generated header to documentation content.
        
        Args:
            content: Original content
            source_file: Source file being documented
            component_type: Type of component
            template: Template used
            
        Returns:
            Content with header added
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        header = f"""<!--
  ðŸ¤– AI-GENERATED DOCUMENTATION
  
  Source File: {source_file}
  Component Type: {component_type}
  Template: {template}
  Generated: {timestamp}
  
  This documentation was generated by the AKR MCP Documentation Server.
  Sections marked with ðŸ¤– are AI-generated.
  Sections marked with â“ need human input.
  
  Please review and enhance with business context before finalizing.
-->

"""
        return header + content
    
    def stage_file(self, file_path: str) -> bool:
        """Stage a file for commit."""
        result = self._run_git("add", file_path)
        return result.returncode == 0
    
    def commit(self, message: str, files: Optional[list[str]] = None) -> bool:
        """
        Commit staged changes.
        
        Args:
            message: Commit message
            files: Optional list of specific files to commit
            
        Returns:
            True if successful
        """
        # Configure git user if not set
        self._ensure_git_config()
        
        # Stage files if specified
        if files:
            for file_path in files:
                self.stage_file(file_path)
        else:
            self._run_git("add", ".")
        
        # Commit
        result = self._run_git("commit", "-m", message)
        
        if result.returncode == 0:
            logger.info(f"Committed: {message}")
            return True
        elif "nothing to commit" in result.stdout.lower():
            logger.info("Nothing to commit")
            return True
        else:
            logger.error(f"Commit failed: {result.stderr}")
            return False
    
    def _ensure_git_config(self):
        """Ensure git user is configured for commits."""
        result = self._run_git("config", "user.email")
        
        if not result.stdout.strip():
            self._run_git("config", "user.name", "AKR Documentation Agent")
            self._run_git("config", "user.email", "akr-agent@noreply.github.com")
    
    def push(self, branch: Optional[str] = None) -> bool:
        """
        Push current branch to remote.
        
        Args:
            branch: Branch name (uses current if None)
            
        Returns:
            True if successful
        """
        if branch:
            result = self._run_git("push", "-u", "origin", branch)
        else:
            result = self._run_git("push")
        
        if result.returncode == 0:
            logger.info(f"Pushed to remote")
            return True
        else:
            logger.error(f"Push failed: {result.stderr}")
            return False
    
    def get_current_branch(self) -> str:
        """Get current branch name."""
        result = self._run_git("rev-parse", "--abbrev-ref", "HEAD")
        return result.stdout.strip() if result.returncode == 0 else "unknown"


def write_documentation(
    repo_path: str,
    doc_path: str,
    content: str,
    source_file: str,
    component_type: str = "unknown",
    template: str = "standard_service_template.md",
    commit_message: Optional[str] = None,
    overwrite: bool = False
) -> dict:
    """
    Write new documentation to the repository.
    
    Args:
        repo_path: Path to the repository
        doc_path: Relative path for the documentation file
        content: Documentation content to write
        source_file: Source file being documented
        component_type: Type of component (services, controllers, etc.)
        template: Template used for generation
        commit_message: Optional custom commit message
        overwrite: Allow overwriting existing files
        
    Returns:
        Dictionary with result information
    """
    writer = DocumentationWriter(repo_path)
    
    # Check if file exists
    if writer.file_exists(doc_path):
        if not overwrite:
            return {
                "success": False,
                "error": f"Documentation already exists at {doc_path}. Use 'overwrite=true' to replace or use surgical update.",
                "filePath": doc_path,
                "exists": True
            }
    
    # Add AI header
    content_with_header = writer.add_ai_header(content, source_file, component_type, template)
    
    # Write file
    if not writer.write_file(doc_path, content_with_header):
        return {
            "success": False,
            "error": f"Failed to write file to {doc_path}",
            "filePath": doc_path
        }
    
    # Stage file
    writer.stage_file(doc_path)
    
    # Generate commit message if not provided
    if not commit_message:
        source_name = Path(source_file).stem
        commit_message = f"docs: add {component_type} documentation for {source_name}"
    
    # Commit
    committed = writer.commit(commit_message, [doc_path])
    
    return {
        "success": True,
        "filePath": doc_path,
        "fullPath": str(Path(repo_path) / doc_path),
        "sourceFile": source_file,
        "componentType": component_type,
        "template": template,
        "committed": committed,
        "commitMessage": commit_message,
        "branch": writer.get_current_branch()
    }


def write_config_file(repo_path: str, config_content: dict) -> dict:
    """
    Write .akr-config.json to the repository.
    
    Args:
        repo_path: Path to the repository
        config_content: Configuration dictionary to write
        
    Returns:
        Dictionary with result information
    """
    import json
    
    writer = DocumentationWriter(repo_path)
    config_path = ".akr-config.json"
    
    # Check if already exists
    if writer.file_exists(config_path):
        return {
            "success": False,
            "error": "Configuration file already exists",
            "filePath": config_path
        }
    
    # Write config
    content = json.dumps(config_content, indent=2)
    if not writer.write_file(config_path, content):
        return {
            "success": False,
            "error": "Failed to write configuration file",
            "filePath": config_path
        }
    
    # Commit
    writer.stage_file(config_path)
    committed = writer.commit("chore: add AKR documentation configuration")
    
    return {
        "success": True,
        "filePath": config_path,
        "fullPath": str(Path(repo_path) / config_path),
        "committed": committed,
        "message": "Configuration file created. Your team can now use AKR documentation without additional setup."
    }

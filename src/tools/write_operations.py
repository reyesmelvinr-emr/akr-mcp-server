"""
Write Operations Module

Handles file writing operations for MCP documentation.
Provides tools for creating new documentation files and committing changes.
"""

import logging
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Optional

from .config_utils import ErrorType, error_response
from .enforcement_tool import enforce_and_fix
from .enforcement_tool_types import FileMetadata
from .section_updater import update_documentation_sections

logger = logging.getLogger("akr-mcp-server.tools.write_operations")


def _insert_ai_header_after_yaml(header: str, content: str) -> str:
    """Insert AI header after YAML front matter if present."""
    lines = content.splitlines()
    if not lines:
        return header

    first_non_empty = next((i for i, line in enumerate(lines) if line.strip()), len(lines))
    if first_non_empty >= len(lines) or lines[first_non_empty].strip() != "---":
        return f"{header}\n{content}"

    for idx in range(first_non_empty + 1, len(lines)):
        if lines[idx].strip() == "---":
            before = "\n".join(lines[: idx + 1])
            after = "\n".join(lines[idx + 1 :])
            if after:
                return f"{before}\n{header}\n{after}"
            return f"{before}\n{header}"

    return f"{header}\n{content}"


def build_ai_header(
    source_file: str,
    component_type: str = "unknown",
    template: str = ""
) -> str:
    """Return header text only (insertion deferred to write path)."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"""<!--
  ðŸ¤– AI-GENERATED DOCUMENTATION

  Source File: {source_file}
  Component Type: {component_type}
  Template: {template}
  Generated: {timestamp}

  This documentation was generated by the AKR MCP Documentation Server.
  Sections marked with ðŸ¤– are AI-generated.
  Sections marked with â“ need human input.

  Please review and enhance with business context before finalizing.
  Enhance with â“ [HUMAN: ...] before merging
-->
"""


class DocumentationWriter:
    """
    Handles writing documentation files to the repository.
    
    Features:
    - Creates documentation files at specified paths
    - Creates parent directories as needed
    - Commits changes with meaningful messages
    - Adds AI-generated markers to content
    """
    
    def __init__(self, repo_path: str):
        """
        Initialize documentation writer.
        
        Args:
            repo_path: Path to the repository
        """
        self.repo_path = Path(repo_path)
    
    def _run_git(self, *args) -> subprocess.CompletedProcess:
        """Run a git command in the repository."""
        cmd = ["git"] + list(args)
        return subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd=self.repo_path
        )
    
    def file_exists(self, file_path: str) -> bool:
        """Check if a file exists in the repository."""
        full_path = self.repo_path / file_path
        return full_path.exists()
    
    def read_file(self, file_path: str) -> Optional[str]:
        """Read contents of a file."""
        full_path = self.repo_path / file_path
        if not full_path.exists():
            return None
        
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Error reading file: {e}")
            return None
    
    def write_file(self, file_path: str, content: str, 
                   create_directories: bool = True) -> bool:
        """
        Write content to a file.
        
        Args:
            file_path: Relative path to the file
            content: Content to write
            create_directories: Create parent directories if needed
            
        Returns:
            True if successful
        """
        full_path = self.repo_path / file_path
        
        try:
            if create_directories:
                full_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.info(f"Wrote file: {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error writing file: {e}")
            return False
    
    def add_ai_header(self, content: str, source_file: str, 
                      component_type: str, template: str) -> str:
        """
        Add AI-generated header to documentation content.
        
        Args:
            content: Original content
            source_file: Source file being documented
            component_type: Type of component
            template: Template used
            
        Returns:
            Content with header added
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        header = f"""<!--
  ðŸ¤– AI-GENERATED DOCUMENTATION
  
  Source File: {source_file}
  Component Type: {component_type}
  Template: {template}
  Generated: {timestamp}
  
  This documentation was generated by the AKR MCP Documentation Server.
  Sections marked with ðŸ¤– are AI-generated.
  Sections marked with â“ need human input.
  
  Please review and enhance with business context before finalizing.
-->

"""
        return header + content
    
    def stage_file(self, file_path: str) -> bool:
        """Stage a file for commit."""
        result = self._run_git("add", file_path)
        return result.returncode == 0
    
    def commit(self, message: str, files: Optional[list[str]] = None) -> bool:
        """
        Commit staged changes.
        
        Args:
            message: Commit message
            files: Optional list of specific files to commit
            
        Returns:
            True if successful
        """
        # Configure git user if not set
        self._ensure_git_config()
        
        # Stage files if specified
        if files:
            for file_path in files:
                self.stage_file(file_path)
        else:
            self._run_git("add", ".")
        
        # Commit
        result = self._run_git("commit", "-m", message)
        
        if result.returncode == 0:
            logger.info(f"Committed: {message}")
            return True
        elif "nothing to commit" in result.stdout.lower():
            logger.info("Nothing to commit")
            return True
        else:
            logger.error(f"Commit failed: {result.stderr}")
            return False
    
    def _ensure_git_config(self):
        """Ensure git user is configured for commits."""
        result = self._run_git("config", "user.email")
        
        if not result.stdout.strip():
            self._run_git("config", "user.name", "AKR Documentation Agent")
            self._run_git("config", "user.email", "akr-agent@noreply.github.com")
    
    def push(self, branch: Optional[str] = None) -> bool:
        """
        Push current branch to remote.
        
        Args:
            branch: Branch name (uses current if None)
            
        Returns:
            True if successful
        """
        if branch:
            result = self._run_git("push", "-u", "origin", branch)
        else:
            result = self._run_git("push")
        
        if result.returncode == 0:
            logger.info(f"Pushed to remote")
            return True
        else:
            logger.error(f"Push failed: {result.stderr}")
            return False
    
    def get_current_branch(self) -> str:
        """Get current branch name."""
        result = self._run_git("rev-parse", "--abbrev-ref", "HEAD")
        return result.stdout.strip() if result.returncode == 0 else "unknown"


def write_documentation(
    repo_path: str,
    doc_path: str,
    content: str,
    source_file: str,
    component_type: str = "unknown",
    template: str = "standard_service_template.md",
    commit_message: Optional[str] = None,
    overwrite: bool = False,
    config: dict | None = None,
    telemetry_logger: object | None = None
) -> dict:
    """
    Write new documentation to the repository.
    
    Args:
        repo_path: Path to the repository
        doc_path: Relative path for the documentation file
        content: Documentation content to write
        source_file: Source file being documented
        component_type: Type of component (services, controllers, etc.)
        template: Template used for generation
        commit_message: Optional custom commit message
        overwrite: Allow overwriting existing files
        
    Returns:
        Dictionary with result information
    """
    config = config or {}
    enforcement_cfg = config.get("documentation", {}).get("enforcement", {})
    if not enforcement_cfg or not enforcement_cfg.get("enabled", False):
        return error_response(
            ErrorType.CONFIG_DISABLED,
            "Documentation enforcement is disabled in config; writes refused for safety"
        )

    repo_root = Path(repo_path).resolve()
    doc_rel = Path(doc_path)
    if doc_rel.is_absolute():
        return error_response(
            ErrorType.PATH_TRAVERSAL,
            f"doc_path must be repo-relative: {doc_path}"
        )

    full_path = (repo_root / doc_rel).resolve()
    try:
        full_path.relative_to(repo_root)
    except ValueError:
        return error_response(
            ErrorType.PATH_TRAVERSAL,
            f"doc_path escapes repository root: {doc_path}"
        )

    writer = DocumentationWriter(repo_path)
    
    # Check if file exists
    if writer.file_exists(doc_path):
        if not overwrite:
            return error_response(
                ErrorType.WRITE_FAILED,
                f"Documentation already exists at {doc_path}. Use 'overwrite=true' to replace or use surgical update.",
                filePath=doc_path,
                exists=True
            )

    file_metadata = FileMetadata(
        file_path=source_file or doc_path,
        component_name=Path(source_file or doc_path).stem
    )

    if telemetry_logger and hasattr(telemetry_logger, "log_event"):
        telemetry_logger.log_event({
            "event_type": "enforcement_start",
            "template": template,
            "doc_path": doc_path,
            "timestamp": datetime.now().isoformat() + "Z"
        })

    try:
        enforcement_result = enforce_and_fix(
            markdown=content,
            template_name=template,
            file_metadata=file_metadata,
            config=config,
            update_mode="replace" if overwrite else "create",
            dry_run=False
        )
    except Exception as e:
        if telemetry_logger and hasattr(telemetry_logger, "log_event"):
            telemetry_logger.log_event({
                "event_type": "enforcement_error",
                "template": template,
                "doc_path": doc_path,
                "error": str(e),
                "timestamp": datetime.now().isoformat() + "Z"
            })
        return error_response(ErrorType.ENFORCEMENT_FAILED, f"Enforcement failed: {e}")

    if telemetry_logger and hasattr(telemetry_logger, "log_event"):
        telemetry_logger.log_event({
            "event_type": "enforcement_result",
            "template": template,
            "doc_path": doc_path,
            "valid": enforcement_result.valid,
            "violation_count": len(enforcement_result.violations),
            "timestamp": datetime.now().isoformat() + "Z"
        })

    if not enforcement_result.valid:
        violations = [
            {
                "type": v.type,
                "severity": getattr(v.severity, "value", str(v.severity)),
                "message": v.message,
                "line": v.line
            }
            for v in enforcement_result.violations
        ]
        return error_response(
            ErrorType.ENFORCEMENT_FAILED,
            "Documentation failed enforcement checks",
            violations=violations,
            summary=enforcement_result.summary,
            auto_fixed=enforcement_result.auto_fixed
        )

    header = build_ai_header(source_file, component_type, template)
    content_with_header = _insert_ai_header_after_yaml(header, enforcement_result.content)

    if not writer.write_file(doc_path, content_with_header):
        return error_response(
            ErrorType.WRITE_FAILED,
            f"Failed to write file to {doc_path}",
            filePath=doc_path
        )
    
    # Stage file
    writer.stage_file(doc_path)
    
    # Generate commit message if not provided
    if not commit_message:
        source_name = Path(source_file).stem
        commit_message = f"docs: add {component_type} documentation for {source_name}"
    
    # Commit
    committed = writer.commit(commit_message, [doc_path])
    
    return {
        "success": True,
        "filePath": doc_path,
        "fullPath": str(Path(repo_path) / doc_path),
        "sourceFile": source_file,
        "componentType": component_type,
        "template": template,
        "committed": committed,
        "commitMessage": commit_message,
        "branch": writer.get_current_branch(),
        "enforcementSummary": enforcement_result.summary,
        "autoFixed": enforcement_result.auto_fixed
    }


def write_config_file(repo_path: str, config_content: dict) -> dict:
    """
    Write .akr-config.json to the repository.
    
    Args:
        repo_path: Path to the repository
        config_content: Configuration dictionary to write
        
    Returns:
        Dictionary with result information
    """
    import json
    
    writer = DocumentationWriter(repo_path)
    config_path = ".akr-config.json"
    
    # Check if already exists
    if writer.file_exists(config_path):
        return {
            "success": False,
            "error": "Configuration file already exists",
            "filePath": config_path
        }
    
    # Write config
    content = json.dumps(config_content, indent=2)
    if not writer.write_file(config_path, content):
        return {
            "success": False,
            "error": "Failed to write configuration file",
            "filePath": config_path
        }
    
    # Commit
    writer.stage_file(config_path)
    committed = writer.commit("chore: add AKR documentation configuration")
    
    return {
        "success": True,
        "filePath": config_path,
        "fullPath": str(Path(repo_path) / config_path),
        "committed": committed,
        "message": "Configuration file created. Your team can now use AKR documentation without additional setup."
    }


def update_documentation_sections_and_commit(
    repo_path: str,
    doc_path: str,
    section_updates: dict[str, str],
    template: str = "standard_service_template.md",
    source_file: str = "",
    component_type: str = "unknown",
    add_changelog: bool = True,
    overwrite: bool = True,
    config: dict | None = None,
    telemetry_logger: object | None = None
) -> dict:
    """
    Update documentation sections, enforce template, and commit changes.
    """
    config = config or {}
    enforcement_cfg = config.get("documentation", {}).get("enforcement", {})
    if not enforcement_cfg or not enforcement_cfg.get("enabled", False):
        return error_response(
            ErrorType.CONFIG_DISABLED,
            "Documentation enforcement is disabled in config; writes refused for safety"
        )

    repo_root = Path(repo_path).resolve()
    doc_rel = Path(doc_path)
    if doc_rel.is_absolute():
        return error_response(
            ErrorType.PATH_TRAVERSAL,
            f"doc_path must be repo-relative: {doc_path}"
        )

    full_path = (repo_root / doc_rel).resolve()
    try:
        full_path.relative_to(repo_root)
    except ValueError:
        return error_response(
            ErrorType.PATH_TRAVERSAL,
            f"doc_path escapes repository root: {doc_path}"
        )

    writer = DocumentationWriter(repo_path)
    existing_content = writer.read_file(doc_path)
    if existing_content is None:
        return error_response(
            ErrorType.FILE_NOT_FOUND,
            f"Documentation not found at {doc_path}",
            filePath=doc_path
        )

    update_result = update_documentation_sections(
        existing_content=existing_content,
        section_updates=section_updates,
        add_changelog=add_changelog
    )

    if not update_result.get("success"):
        return update_result

    updated_content = update_result.get("updated_content", "")
    file_metadata = FileMetadata(
        file_path=source_file or doc_path,
        component_name=Path(source_file or doc_path).stem
    )

    if telemetry_logger and hasattr(telemetry_logger, "log_event"):
        telemetry_logger.log_event({
            "event_type": "enforcement_start",
            "template": template,
            "doc_path": doc_path,
            "timestamp": datetime.now().isoformat() + "Z"
        })

    try:
        enforcement_result = enforce_and_fix(
            markdown=updated_content,
            template_name=template,
            file_metadata=file_metadata,
            config=config,
            update_mode="replace" if overwrite else "create",
            dry_run=False
        )
    except Exception as e:
        if telemetry_logger and hasattr(telemetry_logger, "log_event"):
            telemetry_logger.log_event({
                "event_type": "enforcement_error",
                "template": template,
                "doc_path": doc_path,
                "error": str(e),
                "timestamp": datetime.now().isoformat() + "Z"
            })
        return error_response(ErrorType.ENFORCEMENT_FAILED, f"Enforcement failed: {e}")

    if telemetry_logger and hasattr(telemetry_logger, "log_event"):
        telemetry_logger.log_event({
            "event_type": "enforcement_result",
            "template": template,
            "doc_path": doc_path,
            "valid": enforcement_result.valid,
            "violation_count": len(enforcement_result.violations),
            "timestamp": datetime.now().isoformat() + "Z"
        })

    if not enforcement_result.valid:
        violations = [
            {
                "type": v.type,
                "severity": getattr(v.severity, "value", str(v.severity)),
                "message": v.message,
                "line": v.line
            }
            for v in enforcement_result.violations
        ]
        return error_response(
            ErrorType.ENFORCEMENT_FAILED,
            "Documentation failed enforcement checks",
            violations=violations,
            summary=enforcement_result.summary,
            auto_fixed=enforcement_result.auto_fixed
        )

    header = build_ai_header(source_file, component_type, template)
    content_with_header = _insert_ai_header_after_yaml(header, enforcement_result.content)

    if not writer.write_file(doc_path, content_with_header):
        return error_response(
            ErrorType.WRITE_FAILED,
            f"Failed to write file to {doc_path}",
            filePath=doc_path
        )

    writer.stage_file(doc_path)

    commit_message = f"docs: update documentation sections for {Path(doc_path).stem}"
    committed = writer.commit(commit_message, [doc_path])

    return {
        "success": True,
        "filePath": doc_path,
        "fullPath": str(Path(repo_path) / doc_path),
        "sourceFile": source_file,
        "componentType": component_type,
        "template": template,
        "committed": committed,
        "commitMessage": commit_message,
        "branch": writer.get_current_branch(),
        "updates": update_result.get("updates", []),
        "enforcementSummary": enforcement_result.summary,
        "autoFixed": enforcement_result.auto_fixed
    }
